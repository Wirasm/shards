# Investigation: Terminal scrolling black screen (#467) + cursor visible when TUI apps hide it (#466)

**Issues**: #467 (https://github.com/Wirasm/kild/issues/467), #466 (https://github.com/Wirasm/kild/issues/466)
**Type**: BUG (both)
**Investigated**: 2026-02-17

### Assessment

| Metric     | Value    | Reasoning                                                                                          |
| ---------- | -------- | -------------------------------------------------------------------------------------------------- |
| Severity   | CRITICAL | Both are P0 — #467 makes terminal scrolling completely broken (black screen), #466 shows phantom cursor in TUI apps (visual corruption). Core UI functionality is unusable. |
| Complexity | LOW      | 2 files changed, both in same crate (kild-ui). Changes are well-understood with clear alacritty API patterns already used elsewhere in the codebase. |
| Confidence | HIGH     | Root causes are fully traced with exact line numbers. The fix patterns are proven by Zed's implementation and by existing TermMode usage in our own codebase. |

---

## Problem Statement

**#467**: Scrolling the mouse wheel in the kild-ui terminal causes the content to disappear (black screen). The scroll handler in `TerminalElement::paint()` updates alacritty's `display_offset` but cannot call `cx.notify()` to trigger a GPUI repaint — the closure only receives `&mut App`, not `&mut Context<TerminalView>`.

**#466**: When running TUI apps (Claude Code, vim, htop), a phantom cursor renders at the terminal cursor position even though the app has hidden it via DECTCEM escape sequence (`\e[?25l`). The cursor rendering code only checks a hardcoded `cursor_visible: true` flag and ignores `TermMode::SHOW_CURSOR`.

---

## Analysis

### Root Cause #467: Scroll handler cannot trigger repaint

WHY: Terminal goes black when scrolling
- BECAUSE: GPUI doesn't repaint after scroll offset changes
- Evidence: `terminal_element.rs:800-812` — scroll handler modifies term state but has no `cx.notify()`

WHY: No repaint notification
- BECAUSE: The scroll handler is a closure registered in `paint()` via `window.on_mouse_event::<ScrollWheelEvent>()`. This closure's `_cx` parameter is `&mut App`, which does not provide `notify()`.
- Evidence: `terminal_element.rs:804` — `move |event, phase, window, _cx|`

ROOT CAUSE: Scroll handling is at the wrong layer. It's in `TerminalElement::paint()` (Element layer) where there's no access to `Context<TerminalView>`. It should be in `TerminalView::render()` (View layer) where `cx.listener()` provides full `&mut Context<Self>` access — the same pattern already used for `on_mouse_move`, `on_modifiers_changed`, and `on_key_down`.

### Root Cause #466: Cursor ignores terminal show/hide mode

WHY: Phantom cursor appears in TUI apps
- BECAUSE: Cursor is always rendered when `self.cursor_visible` is true
- Evidence: `terminal_element.rs:581` — `if self.cursor_visible {`

WHY: `cursor_visible` is always true
- BECAUSE: `TerminalView::render()` hardcodes it to `true`
- Evidence: `terminal_view.rs:277` — `true, // cursor_visible`

ROOT CAUSE: The cursor rendering gate at `terminal_element.rs:581` does not check `content.mode.contains(TermMode::SHOW_CURSOR)`. The `TermMode::SHOW_CURSOR` flag is available from `renderable_content().mode` (confirmed in alacritty_terminal 0.25.1) and is already accessed for `APP_CURSOR` at `terminal_view.rs:219-220` — the pattern exists, it just isn't applied to cursor visibility.

### Evidence Chain

```
#467:
terminal_element.rs:804  scroll closure gets &mut App (no notify)
→ terminal_element.rs:809  term.lock().scroll_display(Scroll::Delta(lines))  modifies display_offset
→ GPUI never repaints → black screen

#466:
terminal_view.rs:277     cursor_visible hardcoded to `true`
→ terminal_element.rs:581  `if self.cursor_visible` — no TermMode check
→ Cursor always renders regardless of DECTCEM mode
```

### Affected Files

| File | Lines | Action | Description |
| ---- | ----- | ------ | ----------- |
| `crates/kild-ui/src/terminal/terminal_view.rs` | 1-284 | UPDATE | Add scroll handler method + register in render() + pass TermMode cursor visibility |
| `crates/kild-ui/src/terminal/terminal_element.rs` | 800-812 | UPDATE | Remove scroll handler from paint(), add TermMode check to cursor rendering |

### Integration Points

- `terminal_view.rs:246` — `Render::render()` creates the container div (add `.on_scroll_wheel()`)
- `terminal_view.rs:273-282` — Creates `TerminalElement::new()` (change `cursor_visible` arg)
- `terminal_element.rs:581` — Cursor gate in `prepaint()` (add `content.mode` check)
- `terminal_element.rs:800-812` — Scroll handler in `paint()` (remove entirely)
- `terminal_element.rs:909` — `scroll_delta_lines()` is `pub(crate)` (already accessible from view)

### Git History

- **Last modified**: `442732d` — "fix(ui): fix terminal scroll, remove cursor blink, improve render perf (#451)"
- **Implication**: The scroll handler was previously modified but the repaint issue was not addressed. The cursor blink was removed in that PR, leaving `cursor_visible` as a static `true`.

---

## Implementation Plan

### Step 1: Add scroll handler to TerminalView

**File**: `crates/kild-ui/src/terminal/terminal_view.rs`
**Action**: UPDATE — add new method and import

Add `ScrollWheelEvent` import and `scroll_delta_lines` import:

```rust
use gpui::{
    ClipboardItem, Context, FocusHandle, Focusable, IntoElement, KeyDownEvent, Render,
    ScrollWheelEvent, Task, Window, div, prelude::*, px,
};

use super::terminal_element::scroll_delta_lines;
```

Add `on_scroll_wheel` method to `impl TerminalView` (after `on_modifiers_changed`, before `on_key_down`):

```rust
fn on_scroll_wheel(
    &mut self,
    event: &ScrollWheelEvent,
    window: &mut Window,
    cx: &mut Context<Self>,
) {
    let (_, cell_height) = super::terminal_element::TerminalElement::measure_cell(window, cx);
    let pixel_delta = event.delta.pixel_delta(cell_height);
    let lines = scroll_delta_lines(pixel_delta.y, cell_height);
    if lines != 0 {
        self.terminal.term().lock().scroll_display(
            alacritty_terminal::grid::Scroll::Delta(lines),
        );
        cx.notify();
    }
}
```

**Why**: The View layer has `&mut Context<Self>` which provides `cx.notify()` to trigger GPUI repaint. This mirrors the existing pattern for `on_mouse_move` and `on_modifiers_changed`.

**Note**: `measure_cell` is currently `fn measure_cell(...)` (private). It needs to be made `pub(crate)` so the view can call it.

### Step 2: Make measure_cell accessible from TerminalView

**File**: `crates/kild-ui/src/terminal/terminal_element.rs`
**Lines**: 134
**Action**: UPDATE — change visibility

**Current code:**
```rust
fn measure_cell(window: &mut Window, _cx: &mut App) -> (Pixels, Pixels) {
```

**Required change:**
```rust
pub(crate) fn measure_cell(window: &mut Window, _cx: &mut App) -> (Pixels, Pixels) {
```

**Why**: The view needs access to cell height for scroll delta computation.

### Step 3: Register scroll handler in TerminalView::render()

**File**: `crates/kild-ui/src/terminal/terminal_view.rs`
**Lines**: 252-258
**Action**: UPDATE — add `.on_scroll_wheel()` to container div

**Current code:**
```rust
let mut container = div()
    .track_focus(&self.focus_handle)
    .on_key_down(cx.listener(Self::on_key_down))
    .on_mouse_move(cx.listener(Self::on_mouse_move))
    .on_modifiers_changed(cx.listener(Self::on_modifiers_changed))
    .size_full()
    .bg(theme::terminal_background());
```

**Required change:**
```rust
let mut container = div()
    .track_focus(&self.focus_handle)
    .on_key_down(cx.listener(Self::on_key_down))
    .on_scroll_wheel(cx.listener(Self::on_scroll_wheel))
    .on_mouse_move(cx.listener(Self::on_mouse_move))
    .on_modifiers_changed(cx.listener(Self::on_modifiers_changed))
    .size_full()
    .bg(theme::terminal_background());
```

**Why**: `cx.listener()` wraps the method into the `Fn(&E, &mut Window, &mut App)` signature that `on_scroll_wheel` expects, providing full view context. The div's built-in `on_scroll_wheel` already handles hitbox testing and bubble phase — no manual hitbox check needed.

### Step 4: Remove scroll handler from TerminalElement::paint()

**File**: `crates/kild-ui/src/terminal/terminal_element.rs`
**Lines**: 800-812
**Action**: UPDATE — delete the entire scroll handler block

**Current code to remove:**
```rust
// Scroll wheel handler — translates GPUI scroll events to alacritty display offset.
let hitbox = prepaint.hitbox.clone();
let term = self.term.clone();
let cell_height = prepaint.cell_height;
window.on_mouse_event::<ScrollWheelEvent>(move |event, phase, window, _cx| {
    if phase == DispatchPhase::Bubble && hitbox.should_handle_scroll(window) {
        let pixel_delta = event.delta.pixel_delta(cell_height);
        let lines = scroll_delta_lines(pixel_delta.y, cell_height);
        if lines != 0 {
            term.lock().scroll_display(Scroll::Delta(lines));
        }
    }
});
```

**Why**: Scroll handling is now in TerminalView. Keeping it here would double-handle events.

### Step 5: Clean up unused imports in terminal_element.rs

**File**: `crates/kild-ui/src/terminal/terminal_element.rs`
**Lines**: 10-12
**Action**: UPDATE — remove `ScrollWheelEvent` from imports (if no longer used)

After removing the scroll handler, check if `ScrollWheelEvent` is still used anywhere in the file. If not, remove it from the import block. Similarly check `Scroll` — it may still be used elsewhere, or it may only be in the deleted scroll handler (the `Scroll` import at line 3 is used only in the deleted handler).

Check each:
- `ScrollWheelEvent` (line 12) — only used in deleted handler → **remove**
- `Scroll` (line 3) — only used in deleted handler → **remove**
- `DispatchPhase` (line 10) — check if used elsewhere in paint() (mouse down/move handlers) → **keep if still used**

### Step 6: Add TermMode::SHOW_CURSOR check to cursor rendering

**File**: `crates/kild-ui/src/terminal/terminal_element.rs`
**Lines**: 580-581
**Action**: UPDATE — add mode check

**Current code:**
```rust
// Cursor (only when visible — blink state from TerminalView)
if self.cursor_visible {
```

**Required change:**
```rust
// Cursor (only when visible and terminal has cursor enabled via DECTCEM)
if self.cursor_visible
    && content
        .mode
        .contains(alacritty_terminal::term::TermMode::SHOW_CURSOR)
{
```

**Why**: TUI apps hide the cursor via DECTCEM escape sequence (`\e[?25l`), which clears `TermMode::SHOW_CURSOR`. Without this check, a phantom cursor renders at the terminal's internal cursor position even when the app has hidden it. The `content.mode` field is already available from `renderable_content()` at line 253.

### Step 7: Remove hardcoded cursor_visible from TerminalView (optional simplification)

**File**: `crates/kild-ui/src/terminal/terminal_view.rs`
**Lines**: 277
**Action**: NO CHANGE (keep as-is)

The `cursor_visible` parameter currently means "blink state". Since we removed cursor blink (#451), it's always `true`. The `TermMode::SHOW_CURSOR` check in the element handles the TUI app case. Keeping `cursor_visible: true` is correct — it means "cursor rendering is enabled from the view's perspective" and `TermMode::SHOW_CURSOR` adds the terminal-mode gate.

Future work (out of scope): If cursor blink is re-added (#471), `cursor_visible` would toggle based on blink timer state.

---

## Patterns to Follow

**From codebase — existing View-level event handler pattern:**

```rust
// SOURCE: terminal_view.rs:134-146
// Pattern for View-level mouse event handlers with cx.notify()
fn on_mouse_move(
    &mut self,
    event: &gpui::MouseMoveEvent,
    _window: &mut Window,
    cx: &mut Context<Self>,
) {
    let new_cmd = event.modifiers.platform;
    let new_pos = Some(event.position);
    if self.mouse_state.position != new_pos || self.mouse_state.cmd_held != new_cmd {
        self.mouse_state.position = new_pos;
        self.mouse_state.cmd_held = new_cmd;
        cx.notify();
    }
}
```

**From codebase — existing TermMode flag check pattern:**

```rust
// SOURCE: terminal_view.rs:213-221
// Pattern for checking TermMode flags from terminal content
let app_cursor = {
    let term = self.terminal.term().lock();
    let content = term.renderable_content();
    content
        .mode
        .contains(alacritty_terminal::term::TermMode::APP_CURSOR)
};
```

---

## Edge Cases & Risks

| Risk/Edge Case | Mitigation |
| -------------- | ---------- |
| Scroll fires on wrong terminal in multi-tab layout | `on_scroll_wheel` on div with `track_focus` ensures only focused terminal handles scroll. GPUI's hit testing handles this automatically. |
| `measure_cell()` called every scroll event (performance) | `measure_cell` does a single text shaping call. Font/size never changes mid-session, so the result is stable. Could cache in future but not needed now — the call is ~microseconds. |
| Race between scroll and PTY output rendering | Both lock `term` via FairMutex. Scroll modifies `display_offset`, PTY output adds lines. No race — they take turns. After scroll, `cx.notify()` triggers repaint with updated offset. |
| TUI app that rapidly toggles SHOW_CURSOR | Each frame reads fresh `content.mode` from `renderable_content()`. No stale state — always reflects latest terminal mode. |
| `Scroll` import removal breaks something | Only used in the deleted handler. `scroll_display` is called from view now, importing `Scroll` there instead. |

---

## Validation

### Automated Checks

```bash
cargo fmt --check
cargo clippy --all -- -D warnings
cargo test --all
cargo build --all
```

### Manual Verification

1. **#467 — Scroll works**: Open a daemon kild session, run `seq 200` to generate long output. Scroll up with mouse wheel — should see scrollback history. Scroll down — should return to latest output. No black screen.
2. **#467 — Smooth scrolling**: Scroll rapidly up and down. Content should update on every frame with no flicker.
3. **#466 — TUI cursor hidden**: Run Claude Code in a daemon session. Verify only Claude's visual cursor appears — no phantom cursor at bottom.
4. **#466 — Shell cursor visible**: In a plain shell prompt, verify cursor renders normally at the input position.
5. **#466 — vim/nano**: Open vim or nano. Verify cursor is visible when the app shows it, hidden when it doesn't.

---

## Scope Boundaries

**IN SCOPE:**
- Move scroll handler from Element to View (#467)
- Add `cx.notify()` after scroll (#467)
- Add `TermMode::SHOW_CURSOR` check to cursor rendering (#466)
- Make `measure_cell()` `pub(crate)` for view access
- Clean up unused imports

**OUT OF SCOPE (do not touch):**
- Cursor blink implementation (#471 — separate issue)
- Cursor shape support (Block/Beam/Underline) (#468 — separate issue)
- TerminalContent snapshot pattern from Zed (#469 — separate issue)
- Mouse selection handling (untouched, stays in Element::paint)
- URL click handling (untouched, stays in Element::paint)

---

## Metadata

- **Investigated by**: Claude
- **Timestamp**: 2026-02-17
- **Artifact**: `.claude/PRPs/issues/issue-467-466.md`
