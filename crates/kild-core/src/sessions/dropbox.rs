//! Dropbox messaging protocol — fleet directory setup, protocol generation, and task writes.
//!
//! The dropbox is a per-session directory at `~/.kild/fleet/<project_id>/<branch>/`
//! (where `<branch>` has `/` replaced with `_` for filesystem safety) containing
//! fleet protocol instructions and task files (`task-id`, `task.md`, `history.jsonl`).
//! Created for all real AI agents (claude, codex, gemini, kiro, amp, opencode) when
//! fleet mode is active — no-op for bare shell sessions.

use std::fs::OpenOptions;
use std::io::Write;

use chrono::Utc;
use kild_paths::KildPaths;
use nix::fcntl::{Flock, FlockArg};
use serde::{Deserialize, Serialize};
use tracing::{error, info, warn};

use kild_protocol::BranchName;

use super::agent_status;
use super::errors::SessionError;
use super::fleet;
use super::types::{AgentStatus, Session, SessionStatus};

/// Direction of a fleet message: brain→worker or worker→brain.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub(crate) enum Direction {
    In,
    Out,
}

/// Delivery method used for a task injection.
///
/// Recorded in `history.jsonl` to trace how a task was delivered.
/// Each inject may use multiple methods (e.g. dropbox + inbox for Claude agents).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DeliveryMethod {
    /// File-based dropbox protocol (universal).
    Dropbox,
    /// Claude Code inbox JSON protocol.
    ClaudeInbox,
    /// PTY stdin injection.
    Pty,
    /// Initial prompt written at session creation (before agent starts).
    InitialPrompt,
}

/// A single entry in the append-only `history.jsonl` audit trail.
///
/// Fields are private — construction is internal via `write_task`.
/// Read access is provided through accessor methods.
#[derive(Debug, Serialize, Deserialize)]
pub struct HistoryEntry {
    /// Direction: "in" = brain→worker, "out" = worker→brain.
    dir: Direction,
    /// Sender identifier (e.g. "kild").
    from: String,
    /// Recipient branch name.
    to: String,
    /// Monotonically incrementing task number.
    task_id: u64,
    /// ISO 8601 timestamp with milliseconds.
    ts: String,
    /// First ~80 chars of the task text.
    summary: String,
    /// Delivery methods attempted (e.g. ["dropbox", "claude_inbox"]).
    delivery: Vec<DeliveryMethod>,
}

impl HistoryEntry {
    /// Delivery methods used for this task injection.
    pub fn delivery(&self) -> &[DeliveryMethod] {
        &self.delivery
    }
}

/// Read-only snapshot of a session's dropbox protocol state.
#[derive(Debug, Serialize)]
pub struct DropboxState {
    /// Branch name (for display convenience).
    pub branch: BranchName,
    /// Current task ID from `task-id` file. `None` if no task yet.
    pub task_id: Option<u64>,
    /// Full content of `task.md`. `None` if no task yet.
    pub task_content: Option<String>,
    /// Ack value from `ack` file. `None` if worker hasn't acked.
    pub ack: Option<u64>,
    /// Full content of `report.md`. `None` if worker hasn't reported.
    pub report: Option<String>,
    /// Latest history entry (for delivery method info). `None` if no history.
    pub latest_history: Option<HistoryEntry>,
}

/// A single session's fleet status for the prime context.
#[derive(Debug, Serialize)]
pub struct FleetEntry {
    pub branch: BranchName,
    pub agent: String,
    /// Persisted session lifecycle state (active/stopped/destroyed).
    pub session_status: SessionStatus,
    /// Real-time agent activity state. `None` if no heartbeat on record.
    pub agent_status: Option<AgentStatus>,
    /// Current task ID from this session's own dropbox. `None` if no task assigned.
    pub task_id: Option<u64>,
    /// Task ack from this session's own dropbox. `None` if worker hasn't acked.
    pub ack: Option<u64>,
    /// True when `branch == fleet::BRAIN_BRANCH` ("honryu").
    pub is_brain: bool,
}

/// Full context for priming a fleet agent — current task + fleet status,
/// plus an optional protocol section when available.
///
/// Generated by `generate_prime_context()` and consumed by `kild prime` CLI
/// command. The `to_markdown()` method produces a markdown string suitable for
/// `kild inject worker "$(kild prime worker)"`.
#[derive(Debug, Serialize)]
pub struct PrimeContext {
    pub branch: BranchName,
    pub protocol: Option<String>,
    pub dropbox_state: Option<DropboxState>,
    pub fleet: Vec<FleetEntry>,
}

impl PrimeContext {
    /// Full markdown blob: current task + fleet status, with optional protocol section.
    ///
    /// The `## Your Protocol` section is omitted when `self.protocol` is `None`.
    pub fn to_markdown(&self) -> String {
        let mut out = format!("# KILD Fleet Context — {}\n", self.branch);

        // Protocol section
        if let Some(protocol) = &self.protocol {
            out.push_str("\n## Your Protocol\n\n");
            out.push_str(protocol.trim());
            out.push('\n');
        }

        // Current task section
        out.push_str("\n## Current Task\n\n");
        if let Some(state) = &self.dropbox_state {
            if let Some(task_id) = state.task_id {
                out.push_str(&format!("Task ID: {:03}\n", task_id));
                let ack_str = match state.ack {
                    Some(ack) if ack == task_id => format!("Acked: {} (current)\n", ack),
                    Some(ack) => format!("Acked: {} (stale)\n", ack),
                    None => "Acked: no\n".to_string(),
                };
                out.push_str(&ack_str);
                if let Some(content) = &state.task_content {
                    out.push('\n');
                    out.push_str(content.trim());
                    out.push('\n');
                }
            } else {
                out.push_str("No task assigned.\n");
            }
        } else {
            out.push_str("No task assigned.\n");
        }

        // Fleet status section
        self.append_fleet_table(&mut out);

        out
    }

    /// Fleet status table only (compact output for `--status`).
    pub fn to_status_markdown(&self) -> String {
        let mut out = format!("# Fleet Status — {}\n", self.branch);
        self.append_fleet_table(&mut out);
        out
    }

    fn append_fleet_table(&self, out: &mut String) {
        out.push_str("\n## Fleet Status\n\n");
        if self.fleet.is_empty() {
            out.push_str("No fleet sessions.\n");
            return;
        }

        // Calculate column widths
        let branch_w = self
            .fleet
            .iter()
            .map(|e| e.branch.len())
            .max()
            .unwrap_or(6)
            .max(6);
        let status_w = 10;
        let task_w = 4;
        let ack_w = 4;
        let agent_w = self
            .fleet
            .iter()
            .map(|e| {
                let suffix = if e.is_brain { " (brain)" } else { "" };
                e.agent.len() + suffix.len()
            })
            .max()
            .unwrap_or(5)
            .max(5);

        // Header
        out.push_str(&format!(
            "{:<branch_w$}  {:<status_w$}  {:<task_w$}  {:<ack_w$}  {:<agent_w$}\n",
            "BRANCH", "STATUS", "TASK", "ACK", "AGENT",
        ));

        // Rows
        for entry in &self.fleet {
            let status_str = match &entry.agent_status {
                Some(s) => s.to_string(),
                None => entry.session_status.to_string(),
            };
            let task_str = entry
                .task_id
                .map(|id| format!("{id:03}"))
                .unwrap_or_else(|| "—".to_string());
            let ack_str = entry
                .ack
                .map(|a| format!("{a:03}"))
                .unwrap_or_else(|| "—".to_string());
            let agent_str = if entry.is_brain {
                format!("{} (brain)", entry.agent)
            } else {
                entry.agent.clone()
            };

            out.push_str(&format!(
                "{:<branch_w$}  {:<status_w$}  {:<task_w$}  {:<ack_w$}  {:<agent_w$}\n",
                &*entry.branch, status_str, task_str, ack_str, agent_str,
            ));
        }
    }
}

/// Ensure the dropbox directory exists with a current `protocol.md`.
///
/// Idempotent: creates directory if missing, overwrites `protocol.md` on every call
/// (picks up template changes). Best-effort: warns on failure, never blocks session
/// creation/opening. No-op for non-agent sessions (shell) or when fleet is not active.
pub(super) fn ensure_dropbox(project_id: &str, branch: &str, agent: &str) {
    if !fleet::is_dropbox_capable_agent(agent) || !fleet::fleet_mode_active(branch) {
        return;
    }

    let paths = match KildPaths::resolve() {
        Ok(p) => p,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.paths_resolve_failed",
                error = %e,
            );
            eprintln!(
                "Warning: Failed to resolve kild paths — dropbox will not be created for '{}': {}",
                branch, e,
            );
            return;
        }
    };

    let dropbox_dir = paths.fleet_dropbox_dir(project_id, branch);

    if let Err(e) = std::fs::create_dir_all(&dropbox_dir) {
        warn!(
            event = "core.session.dropbox.create_dir_failed",
            branch = branch,
            path = %dropbox_dir.display(),
            error = %e,
        );
        eprintln!(
            "Warning: Failed to create dropbox directory at {}: {}",
            dropbox_dir.display(),
            e,
        );
        return;
    }

    let protocol_path = dropbox_dir.join("protocol.md");
    let protocol_content = generate_protocol(branch, &dropbox_dir);

    if let Err(e) = std::fs::write(&protocol_path, protocol_content) {
        warn!(
            event = "core.session.dropbox.protocol_write_failed",
            branch = branch,
            path = %protocol_path.display(),
            error = %e,
        );
        eprintln!(
            "Warning: Failed to write protocol.md at {}: {}",
            protocol_path.display(),
            e,
        );
        return;
    }

    info!(
        event = "core.session.dropbox.ensure_completed",
        branch = branch,
        path = %dropbox_dir.display(),
    );
}

/// Write task files to a worker's dropbox.
///
/// Increments `task-id`, writes `task.md` with a `# Task NNN` heading,
/// and appends to `history.jsonl`. No-op (returns `Ok(None)`) if fleet mode
/// is not active or the dropbox directory does not exist.
/// Returns `Ok(Some(task_id))` on success with the new task number.
///
/// Uses an exclusive flock on `task.lock` to prevent concurrent writers
/// (e.g. create --initial-prompt racing with inject) from producing
/// duplicate task IDs.
///
/// Note: `write_task` does NOT check `is_dropbox_capable_agent` — it relies on
/// `ensure_dropbox` (which IS agent-guarded) to control which sessions get a
/// dropbox directory. If the directory exists, the task is written.
pub fn write_task(
    project_id: &str,
    branch: &str,
    text: &str,
    delivery: &[DeliveryMethod],
) -> Result<Option<u64>, SessionError> {
    if !fleet::fleet_mode_active(branch) {
        return Ok(None);
    }

    let paths = KildPaths::resolve().map_err(|e| SessionError::IoError {
        source: std::io::Error::other(e),
    })?;
    let dropbox_dir = paths.fleet_dropbox_dir(project_id, branch);

    if !dropbox_dir.exists() {
        return Ok(None);
    }

    info!(
        event = "core.session.dropbox.write_task_started",
        branch = branch,
        text_len = text.len(),
    );

    // Acquire exclusive lock for the duration of the read-modify-write.
    // Mirrors the flock pattern in inject.rs::write_to_inbox.
    let lock_path = dropbox_dir.join("task.lock");
    let lock_file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(false)
        .open(&lock_path)
        .map_err(|e| SessionError::IoError { source: e })?;
    let _lock = Flock::lock(lock_file, FlockArg::LockExclusive)
        .map_err(|(_, e)| SessionError::IoError { source: e.into() })?;

    // Read current task-id, distinguishing: missing (normal) vs corrupt (warn) vs unreadable (error).
    let task_id_path = dropbox_dir.join("task-id");
    let current_id: u64 = match std::fs::read_to_string(&task_id_path) {
        Ok(s) => {
            let trimmed = s.trim();
            match trimmed.parse::<u64>() {
                Ok(id) => id,
                Err(e) => {
                    warn!(
                        event = "core.session.dropbox.task_id_corrupt",
                        branch = branch,
                        path = %task_id_path.display(),
                        content = trimmed,
                        error = %e,
                    );
                    0
                }
            }
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => 0,
        Err(e) => {
            error!(
                event = "core.session.dropbox.task_id_read_failed",
                branch = branch,
                path = %task_id_path.display(),
                error = %e,
            );
            return Err(SessionError::IoError { source: e });
        }
    };
    let new_id = current_id + 1;

    // Write task-id.
    std::fs::write(&task_id_path, format!("{new_id}\n")).map_err(|e| {
        error!(
            event = "core.session.dropbox.write_task_id_failed",
            branch = branch,
            task_id = new_id,
            path = %task_id_path.display(),
            error = %e,
        );
        SessionError::IoError { source: e }
    })?;

    // Write task.md — roll back task-id on failure to keep files consistent.
    let task_path = dropbox_dir.join("task.md");
    if let Err(e) = std::fs::write(&task_path, format!("# Task {new_id}\n\n{text}\n")) {
        error!(
            event = "core.session.dropbox.write_task_md_failed",
            branch = branch,
            task_id = new_id,
            path = %task_path.display(),
            error = %e,
        );
        // Roll back task-id so the next write gets the same number.
        let _ = std::fs::write(&task_id_path, format!("{current_id}\n"));
        return Err(SessionError::IoError { source: e });
    }

    // Clear the idle gate file immediately after task.md succeeds, since task delivery
    // is now confirmed. The claude-status hook creates .idle_sent on the first idle event;
    // we clear it here to reset the dedup gate for the next task cycle.
    // Must happen before history.jsonl (which can fail and return early).
    // Best-effort: if removal fails, the stale gate will suppress the next idle inject.
    // Logged at warn level — the task was delivered, so write_task returns Ok regardless.
    remove_idle_gate_file(&dropbox_dir.join(".idle_sent"), branch);

    // Append history.jsonl — task delivery already succeeded via task.md;
    // log loudly on failure but do not roll back the task files.
    let history_path = dropbox_dir.join("history.jsonl");
    let summary: String = text.lines().next().unwrap_or("").chars().take(80).collect();
    let entry = HistoryEntry {
        dir: Direction::In,
        from: "kild".to_string(),
        to: branch.to_string(),
        task_id: new_id,
        ts: Utc::now().format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string(),
        summary,
        delivery: delivery.to_vec(),
    };
    let json_line = serde_json::to_string(&entry).map_err(|e| SessionError::IoError {
        source: std::io::Error::new(std::io::ErrorKind::InvalidData, e),
    })?;
    let write_history_result = OpenOptions::new()
        .create(true)
        .append(true)
        .open(&history_path)
        .and_then(|mut file| writeln!(file, "{}", json_line));
    if let Err(e) = write_history_result {
        error!(
            event = "core.session.dropbox.write_history_failed",
            branch = branch,
            task_id = new_id,
            path = %history_path.display(),
            error = %e,
        );
        return Err(SessionError::IoError { source: e });
    }

    info!(
        event = "core.session.dropbox.write_task_completed",
        branch = branch,
        task_id = new_id,
    );

    Ok(Some(new_id))
}

/// Remove the `.idle_sent` gate file at the given path (best-effort).
///
/// No-op if the file does not exist. Warns on removal failure.
/// Shared by `write_task` (inline gate clear) and `clear_idle_gate` (open-session path).
fn remove_idle_gate_file(gate_path: &std::path::Path, branch: &str) {
    if gate_path.exists() {
        if let Err(e) = std::fs::remove_file(gate_path) {
            warn!(
                event = "core.session.dropbox.idle_gate_clear_failed",
                branch = branch,
                path = %gate_path.display(),
                error = %e,
            );
        } else {
            info!(
                event = "core.session.dropbox.idle_gate_cleared",
                branch = branch,
            );
        }
    }
}

/// Clear the `.idle_sent` gate file in a session's dropbox directory.
///
/// The gate file is created by the `claude-status` hook after the first idle event.
/// It must be cleared when new work is delivered (task injection or initial prompt)
/// so the next idle event triggers a brain notification.
///
/// No-op if fleet mode is not active, the dropbox does not exist, or the gate file
/// is already absent. Best-effort: warns on removal failure.
pub(super) fn clear_idle_gate(project_id: &str, branch: &str) {
    if !fleet::fleet_mode_active(branch) {
        return;
    }

    let paths = match KildPaths::resolve() {
        Ok(p) => p,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.idle_gate_path_resolve_failed",
                branch = branch,
                error = %e,
            );
            return;
        }
    };

    let gate_path = paths
        .fleet_dropbox_dir(project_id, branch)
        .join(".idle_sent");
    remove_idle_gate_file(&gate_path, branch);
}

/// Inject `KILD_DROPBOX` (and `KILD_FLEET_DIR` for brain) into daemon env vars.
///
/// No-op for non-agent sessions (shell) or when fleet mode is not active.
/// Best-effort: warns and skips injection if path resolution fails.
/// Called at the call site after `build_daemon_create_request` returns,
/// to avoid modifying that function's signature.
pub(super) fn inject_dropbox_env_vars(
    env_vars: &mut Vec<(String, String)>,
    project_id: &str,
    branch: &str,
    agent: &str,
) {
    if !fleet::is_dropbox_capable_agent(agent) || !fleet::fleet_mode_active(branch) {
        return;
    }

    let paths = match KildPaths::resolve() {
        Ok(p) => p,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.env_paths_resolve_failed",
                error = %e,
            );
            eprintln!(
                "Warning: Failed to resolve kild paths — KILD_DROPBOX will not be set for '{}': {}",
                branch, e,
            );
            return;
        }
    };

    let dropbox = paths.fleet_dropbox_dir(project_id, branch);
    let Some(dropbox_str) = dropbox.to_str() else {
        warn!(
            event = "core.session.dropbox.env_path_not_utf8",
            branch = branch,
            path = %dropbox.display(),
        );
        eprintln!(
            "Warning: Dropbox path is not valid UTF-8, KILD_DROPBOX will not be set: {}",
            dropbox.display(),
        );
        return;
    };
    env_vars.push(("KILD_DROPBOX".to_string(), dropbox_str.to_string()));

    if branch == fleet::BRAIN_BRANCH {
        let fleet_dir = paths.fleet_project_dir(project_id);
        let Some(fleet_dir_str) = fleet_dir.to_str() else {
            warn!(
                event = "core.session.dropbox.env_fleet_dir_not_utf8",
                branch = branch,
                path = %fleet_dir.display(),
            );
            return;
        };
        env_vars.push(("KILD_FLEET_DIR".to_string(), fleet_dir_str.to_string()));
    }

    info!(
        event = "core.session.dropbox.env_injected",
        branch = branch,
        dropbox = %dropbox.display(),
    );
}

/// Read the current dropbox protocol state for a session.
///
/// Returns `Ok(None)` if fleet mode is not active or the dropbox directory
/// does not exist (normal for non-fleet sessions). Each file is read
/// independently — a missing or corrupt individual file yields `None` for
/// that field (with a warning log), not an error for the whole read.
pub fn read_dropbox_state(
    project_id: &str,
    branch: &str,
) -> Result<Option<DropboxState>, SessionError> {
    if !fleet::fleet_mode_active(branch) {
        return Ok(None);
    }

    let paths = KildPaths::resolve().map_err(|e| SessionError::IoError {
        source: std::io::Error::other(e),
    })?;
    let dropbox_dir = paths.fleet_dropbox_dir(project_id, branch);

    if !dropbox_dir.exists() {
        return Ok(None);
    }

    let task_id = read_optional_u64(&dropbox_dir.join("task-id"), branch);
    let task_content = read_optional_string(&dropbox_dir.join("task.md"), branch);
    let ack = read_optional_u64(&dropbox_dir.join("ack"), branch);
    let report = read_optional_string(&dropbox_dir.join("report.md"), branch);
    let latest_history = read_latest_history(&dropbox_dir.join("history.jsonl"), branch);

    Ok(Some(DropboxState {
        branch: BranchName::from(branch),
        task_id,
        task_content,
        ack,
        report,
        latest_history,
    }))
}

/// Generate full fleet context for priming an agent.
///
/// Returns `Ok(None)` if fleet mode is not active. Reads protocol, dropbox state,
/// and fleet-wide entries from all provided sessions. Used by `kild prime` CLI.
///
/// Note: `sessions` is not filtered by project — the caller is responsible
/// for passing only sessions belonging to the relevant project.
pub fn generate_prime_context(
    project_id: &str,
    branch: &str,
    sessions: &[Session],
) -> Result<Option<PrimeContext>, SessionError> {
    if !fleet::fleet_mode_active(branch) {
        return Ok(None);
    }

    info!(
        event = "core.session.prime.generate_started",
        branch = branch,
    );

    let paths = KildPaths::resolve().map_err(|e| {
        error!(
            event = "core.session.prime.generate_failed",
            branch = branch,
            error = %e,
        );
        SessionError::IoError {
            source: std::io::Error::other(e),
        }
    })?;
    let dropbox_dir = paths.fleet_dropbox_dir(project_id, branch);

    let protocol = if dropbox_dir.exists() {
        let p = read_optional_string(&dropbox_dir.join("protocol.md"), branch);
        if p.is_none() {
            warn!(
                event = "core.session.prime.protocol_missing",
                branch = branch,
                dropbox_dir = %dropbox_dir.display(),
            );
        }
        p
    } else {
        None
    };

    let dropbox_state = read_dropbox_state(project_id, branch)?;

    let mut fleet = Vec::new();
    for session in sessions {
        let entry_state = read_dropbox_state(&session.project_id, &session.branch);
        let (task_id, ack) = match entry_state {
            Ok(Some(s)) => (s.task_id, s.ack),
            Ok(None) => (None, None),
            Err(e) => {
                warn!(
                    event = "core.session.prime.dropbox_read_failed",
                    branch = %session.branch,
                    error = %e,
                );
                (None, None)
            }
        };

        // read_agent_status returns None for both "no status yet" and file read
        // failures; the latter is silent by design in the current persistence layer.
        let agent_status_info = agent_status::read_agent_status(&session.id);

        fleet.push(FleetEntry {
            branch: session.branch.clone(),
            agent: session.agent.clone(),
            session_status: session.status.clone(),
            agent_status: agent_status_info.map(|info| info.status),
            task_id,
            ack,
            is_brain: &*session.branch == fleet::BRAIN_BRANCH,
        });
    }

    info!(
        event = "core.session.prime.generate_completed",
        branch = branch,
        fleet_count = fleet.len(),
    );

    Ok(Some(PrimeContext {
        branch: BranchName::from(branch),
        protocol,
        dropbox_state,
        fleet,
    }))
}

/// Read a file as a trimmed u64, returning None on missing or parse failure.
fn read_optional_u64(path: &std::path::Path, branch: &str) -> Option<u64> {
    match std::fs::read_to_string(path) {
        Ok(s) => match s.trim().parse::<u64>() {
            Ok(v) => Some(v),
            Err(e) => {
                warn!(
                    event = "core.session.dropbox.read_parse_failed",
                    branch = branch,
                    path = %path.display(),
                    error = %e,
                );
                None
            }
        },
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => None,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.read_u64_failed",
                branch = branch,
                path = %path.display(),
                error = %e,
            );
            None
        }
    }
}

/// Read a file as a string, returning None if missing or empty.
fn read_optional_string(path: &std::path::Path, branch: &str) -> Option<String> {
    match std::fs::read_to_string(path) {
        Ok(s) if s.trim().is_empty() => None,
        Ok(s) => Some(s),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => None,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.read_string_failed",
                branch = branch,
                path = %path.display(),
                error = %e,
            );
            None
        }
    }
}

/// Read the last line of history.jsonl and parse as HistoryEntry.
fn read_latest_history(path: &std::path::Path, branch: &str) -> Option<HistoryEntry> {
    let content = match std::fs::read_to_string(path) {
        Ok(c) => c,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => return None,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.read_history_failed",
                branch = branch,
                path = %path.display(),
                error = %e,
            );
            return None;
        }
    };
    let last_line = content.lines().rev().find(|l| !l.trim().is_empty())?;
    match serde_json::from_str::<HistoryEntry>(last_line) {
        Ok(entry) => Some(entry),
        Err(e) => {
            warn!(
                event = "core.session.dropbox.read_history_parse_failed",
                branch = branch,
                path = %path.display(),
                error = %e,
            );
            None
        }
    }
}

/// Clean up the dropbox directory for a session. Best-effort.
///
/// Always called — not gated on fleet mode or agent type. Returns immediately
/// if the directory does not exist (normal case for non-fleet sessions).
pub(super) fn cleanup_dropbox(project_id: &str, branch: &str) {
    let paths = match KildPaths::resolve() {
        Ok(p) => p,
        Err(e) => {
            warn!(
                event = "core.session.dropbox.cleanup_paths_failed",
                error = %e,
            );
            eprintln!(
                "Warning: Failed to resolve kild paths — dropbox for '{}' was not cleaned up: {}",
                branch, e,
            );
            return;
        }
    };

    let dropbox_dir = paths.fleet_dropbox_dir(project_id, branch);

    if !dropbox_dir.exists() {
        return;
    }

    if let Err(e) = std::fs::remove_dir_all(&dropbox_dir) {
        warn!(
            event = "core.session.dropbox.cleanup_failed",
            branch = branch,
            path = %dropbox_dir.display(),
            error = %e,
        );
        eprintln!(
            "Warning: Failed to remove dropbox at {}: {}",
            dropbox_dir.display(),
            e,
        );
    } else {
        info!(
            event = "core.session.dropbox.cleanup_completed",
            branch = branch,
        );
    }
}

/// Generate protocol.md content with baked-in absolute paths.
///
/// Produces a brain-specific template when `branch` matches `BRAIN_BRANCH`,
/// otherwise produces the standard worker template.
fn generate_protocol(branch: &str, dropbox_dir: &std::path::Path) -> String {
    let dropbox = dropbox_dir.display();
    // NOTE: Raw string content is flush-left to avoid embedding leading whitespace.
    // This matches the pattern in daemon_helpers.rs for hook script generation.
    if branch == fleet::BRAIN_BRANCH {
        // Brain gets the fleet project dir (parent of its own dropbox).
        let fleet_dir = match dropbox_dir.parent() {
            Some(p) => p.display().to_string(),
            None => {
                warn!(
                    event = "core.session.dropbox.brain_fleet_dir_missing",
                    branch = branch,
                    dropbox = %dropbox_dir.display(),
                );
                "$KILD_FLEET_DIR".to_string()
            }
        };
        format!(
            r##"# KILD Fleet Protocol — Brain

You are the Honryū fleet supervisor. You manage workers by writing tasks to their dropboxes and reading their reports.

## Directing Workers

Worker dropboxes: {fleet_dir}/<worker-branch>/

To assign a task:
1. Use `kild inject <worker> "your task description"` to write the task
   (this updates task.md, task-id, and history.jsonl atomically)
2. The worker reads task.md and writes ack
3. The worker executes and writes report.md
4. Read report.md to get results

## File Paths (per worker)

- Task:   {fleet_dir}/<worker>/task.md
- Ack:    {fleet_dir}/<worker>/ack
- Report: {fleet_dir}/<worker>/report.md

## Your Own Dropbox

Your dropbox: {dropbox}

## Rules

- Use `kild inject` to assign tasks — do not write task.md directly
- Check ack to confirm the worker has picked up the task
- Read report.md to get results before assigning the next task
- Do not modify worker ack or report.md — those are written by workers
"##
        )
    } else {
        format!(
            r##"# KILD Fleet Protocol

You are a worker in a KILD fleet managed by the Honryu brain supervisor.

## Receiving Tasks

Your dropbox: {dropbox}

On startup and after completing each task:
1. Read task.md from your dropbox for your current task
2. Write the task number (from the "# Task NNN" heading) to ack
3. Execute the task fully
4. Write your results to report.md
5. Stop and wait for the next instruction

## File Paths

- Task: {dropbox}/task.md
- Ack:  {dropbox}/ack
- Report: {dropbox}/report.md

## Rules

- Always read task.md before starting work
- Always write ack immediately after reading task.md
- Always write report.md when done
- Do not modify task.md — it is written by the brain
"##
        )
    }
}

#[cfg(test)]
mod tests {
    use std::sync::Mutex;

    use super::*;

    /// Serialize tests that mutate HOME and CLAUDE_CONFIG_DIR — env vars are process-global.
    static DROPBOX_ENV_LOCK: Mutex<()> = Mutex::new(());

    /// Set up temp dirs and override HOME + CLAUDE_CONFIG_DIR for a test.
    ///
    /// When `fleet_active` is true, creates the Honryū team directory so
    /// `fleet_mode_active` returns true for non-brain branches. The callback
    /// receives the HOME dir; the dropbox will be at `<home>/.kild/fleet/...`.
    fn with_env(test_name: &str, fleet_active: bool, f: impl FnOnce(&std::path::Path)) {
        let _lock = DROPBOX_ENV_LOCK.lock().unwrap();
        let base = std::env::temp_dir().join(format!(
            "kild_dropbox_test_{}_{}",
            test_name,
            std::process::id()
        ));
        let _ = std::fs::remove_dir_all(&base);

        let claude_dir = base.join("claude_config");
        if fleet_active {
            // Create the team dir so fleet_mode_active returns true.
            let team_dir = claude_dir.join("teams").join(fleet::BRAIN_BRANCH);
            std::fs::create_dir_all(&team_dir).unwrap();
        } else {
            std::fs::create_dir_all(&claude_dir).unwrap();
        }

        let home_dir = base.join("home");
        std::fs::create_dir_all(&home_dir).unwrap();

        // SAFETY: DROPBOX_ENV_LOCK serializes all env mutations in this module.
        unsafe {
            std::env::set_var("CLAUDE_CONFIG_DIR", &claude_dir);
            std::env::set_var("HOME", &home_dir);
        }
        f(&home_dir);
        let _ = std::fs::remove_dir_all(&base);
        // SAFETY: restoring env; lock still held.
        unsafe {
            std::env::remove_var("CLAUDE_CONFIG_DIR");
            std::env::remove_var("HOME");
        }
    }

    // --- generate_protocol (worker) ---

    #[test]
    fn generate_protocol_worker_contains_baked_absolute_paths() {
        let content = generate_protocol(
            "my-branch",
            std::path::Path::new("/home/user/.kild/fleet/abc/my-branch"),
        );
        assert!(content.contains("/home/user/.kild/fleet/abc/my-branch"));
        assert!(content.contains("/home/user/.kild/fleet/abc/my-branch/task.md"));
        assert!(content.contains("/home/user/.kild/fleet/abc/my-branch/ack"));
        assert!(content.contains("/home/user/.kild/fleet/abc/my-branch/report.md"));
    }

    #[test]
    fn generate_protocol_worker_contains_instructions() {
        let content = generate_protocol("my-branch", std::path::Path::new("/tmp/dropbox"));
        assert!(content.contains("KILD Fleet Protocol"));
        assert!(content.contains("You are a worker"));
        assert!(content.contains("Read task.md"));
        assert!(content.contains("Write your results to report.md"));
        assert!(content.contains("Do not modify task.md"));
    }

    // --- generate_protocol (brain) ---

    #[test]
    fn generate_protocol_brain_contains_supervisor_instructions() {
        let content = generate_protocol(
            fleet::BRAIN_BRANCH,
            std::path::Path::new("/home/user/.kild/fleet/abc/honryu"),
        );
        assert!(
            content.contains("Fleet Protocol — Brain"),
            "brain should get brain-specific header"
        );
        assert!(
            content.contains("fleet supervisor"),
            "brain should be addressed as supervisor"
        );
        assert!(
            !content.contains("You are a worker"),
            "brain must NOT get worker instructions"
        );
    }

    #[test]
    fn generate_protocol_brain_contains_fleet_dir_paths() {
        let content = generate_protocol(
            fleet::BRAIN_BRANCH,
            std::path::Path::new("/home/user/.kild/fleet/abc/honryu"),
        );
        // Fleet dir is the parent of the brain's dropbox dir.
        assert!(
            content.contains("/home/user/.kild/fleet/abc/<worker-branch>/"),
            "brain template should reference fleet dir for worker dropboxes"
        );
        assert!(
            content.contains("/home/user/.kild/fleet/abc/<worker>/task.md"),
            "brain template should show per-worker task.md path"
        );
        assert!(
            content.contains("/home/user/.kild/fleet/abc/<worker>/report.md"),
            "brain template should show per-worker report.md path"
        );
    }

    #[test]
    fn generate_protocol_brain_rules_are_supervisor_oriented() {
        let content = generate_protocol(
            fleet::BRAIN_BRANCH,
            std::path::Path::new("/tmp/fleet/honryu"),
        );
        assert!(content.contains("kild inject"));
        assert!(content.contains("Check ack"));
        assert!(content.contains("Read report.md to get results"));
        assert!(content.contains("Do not modify worker ack or report.md"));
    }

    // --- ensure_dropbox ---

    #[test]
    fn ensure_dropbox_creates_directory_and_protocol() {
        with_env("creates_dir", true, |home| {
            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(!dropbox_dir.exists());

            ensure_dropbox("proj123", "my-branch", "claude");

            assert!(dropbox_dir.exists());
            let protocol_path = dropbox_dir.join("protocol.md");
            assert!(protocol_path.exists());

            let written = std::fs::read_to_string(&protocol_path).unwrap();
            assert!(
                written.contains(&dropbox_dir.display().to_string()),
                "protocol.md should contain baked-in absolute paths under {}/",
                home.display(),
            );
        });
    }

    #[test]
    fn ensure_dropbox_brain_gets_brain_template() {
        with_env("brain_template", true, |_| {
            ensure_dropbox("proj123", fleet::BRAIN_BRANCH, "claude");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", fleet::BRAIN_BRANCH);
            let content = std::fs::read_to_string(dropbox_dir.join("protocol.md")).unwrap();
            assert!(
                content.contains("fleet supervisor"),
                "brain must get supervisor template"
            );
            assert!(
                !content.contains("You are a worker"),
                "brain must not get worker template"
            );
        });
    }

    #[test]
    fn ensure_dropbox_is_idempotent() {
        with_env("idempotent", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            ensure_dropbox("proj123", "my-branch", "claude");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(dropbox_dir.join("protocol.md").exists());
        });
    }

    #[test]
    fn ensure_dropbox_creates_for_non_claude_agent() {
        with_env("non_claude", true, |_| {
            ensure_dropbox("proj123", "my-branch", "codex");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(
                dropbox_dir.exists(),
                "non-claude agent should get a dropbox"
            );
            assert!(
                dropbox_dir.join("protocol.md").exists(),
                "protocol.md should be created"
            );
        });
    }

    #[test]
    fn ensure_dropbox_noop_for_shell_session() {
        with_env("shell_noop", true, |_| {
            ensure_dropbox("proj123", "my-branch", "shell");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(
                !dropbox_dir.exists(),
                "bare shell session should not create dropbox"
            );
        });
    }

    #[test]
    fn ensure_dropbox_noop_when_fleet_not_active() {
        with_env("no_fleet", false, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(
                !dropbox_dir.exists(),
                "should not create dropbox when fleet is not active"
            );
        });
    }

    // --- cleanup_dropbox ---

    #[test]
    fn cleanup_dropbox_removes_existing_directory() {
        with_env("cleanup_removes", true, |_| {
            // Create the dropbox first
            ensure_dropbox("proj123", "my-branch", "claude");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(dropbox_dir.exists());

            cleanup_dropbox("proj123", "my-branch");
            assert!(
                !dropbox_dir.exists(),
                "cleanup should remove the dropbox directory"
            );
        });
    }

    #[test]
    fn cleanup_dropbox_noop_when_missing() {
        with_env("cleanup_noop", true, |_| {
            // Call cleanup on a session that never had a dropbox — should not panic
            cleanup_dropbox("proj123", "never-existed");
        });
    }

    // --- inject_dropbox_env_vars ---

    #[test]
    fn inject_env_vars_pushes_kild_dropbox_for_worker() {
        with_env("inject_worker", true, |_| {
            let mut env_vars: Vec<(String, String)> = vec![];
            inject_dropbox_env_vars(&mut env_vars, "proj123", "worker", "claude");

            let keys: Vec<&str> = env_vars.iter().map(|(k, _)| k.as_str()).collect();
            assert!(
                keys.contains(&"KILD_DROPBOX"),
                "KILD_DROPBOX must be injected for worker"
            );
            assert!(
                !keys.contains(&"KILD_FLEET_DIR"),
                "KILD_FLEET_DIR must NOT be injected for non-brain worker"
            );
            assert!(env_vars[0].1.contains("fleet/proj123/worker"));
        });
    }

    #[test]
    fn inject_env_vars_brain_gets_fleet_dir() {
        with_env("inject_brain", true, |_| {
            let mut env_vars: Vec<(String, String)> = vec![];
            inject_dropbox_env_vars(&mut env_vars, "proj123", fleet::BRAIN_BRANCH, "claude");

            let keys: Vec<&str> = env_vars.iter().map(|(k, _)| k.as_str()).collect();
            assert!(keys.contains(&"KILD_DROPBOX"));
            assert!(
                keys.contains(&"KILD_FLEET_DIR"),
                "brain must get KILD_FLEET_DIR"
            );
            assert!(env_vars[1].1.contains("fleet/proj123"));
        });
    }

    #[test]
    fn inject_env_vars_works_for_non_claude_agent() {
        with_env("inject_non_claude", true, |_| {
            let mut env_vars: Vec<(String, String)> = vec![];
            inject_dropbox_env_vars(&mut env_vars, "proj123", "worker", "codex");

            let keys: Vec<&str> = env_vars.iter().map(|(k, _)| k.as_str()).collect();
            assert!(
                keys.contains(&"KILD_DROPBOX"),
                "non-claude agent should get KILD_DROPBOX"
            );
            assert!(
                !keys.contains(&"KILD_FLEET_DIR"),
                "non-brain worker should NOT get KILD_FLEET_DIR"
            );
        });
    }

    #[test]
    fn inject_env_vars_noop_for_shell_session() {
        with_env("inject_shell", true, |_| {
            let mut env_vars: Vec<(String, String)> = vec![];
            inject_dropbox_env_vars(&mut env_vars, "proj123", "worker", "shell");

            assert!(
                env_vars.is_empty(),
                "shell session should not get dropbox env vars"
            );
        });
    }

    #[test]
    fn inject_env_vars_noop_when_fleet_not_active() {
        with_env("inject_no_fleet", false, |_| {
            let mut env_vars: Vec<(String, String)> = vec![];
            inject_dropbox_env_vars(&mut env_vars, "proj123", "worker", "claude");

            assert!(
                env_vars.is_empty(),
                "should not inject env vars when fleet is not active"
            );
        });
    }

    // --- write_task ---

    #[test]
    fn write_task_creates_all_three_files() {
        with_env("wt_creates_files", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let result = write_task(
                "proj123",
                "my-branch",
                "Implement OAuth",
                &[DeliveryMethod::Dropbox],
            );
            assert_eq!(result.unwrap(), Some(1));

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");

            // task-id
            let tid = std::fs::read_to_string(dropbox_dir.join("task-id")).unwrap();
            assert_eq!(tid, "1\n");

            // task.md
            let task = std::fs::read_to_string(dropbox_dir.join("task.md")).unwrap();
            assert!(task.starts_with("# Task 1\n\n"));
            assert!(task.contains("Implement OAuth"));

            // history.jsonl — single line, valid JSON
            let history = std::fs::read_to_string(dropbox_dir.join("history.jsonl")).unwrap();
            let lines: Vec<&str> = history.lines().collect();
            assert_eq!(lines.len(), 1);
            let entry: serde_json::Value = serde_json::from_str(lines[0]).unwrap();
            assert_eq!(entry["dir"], "in");
            assert_eq!(entry["from"], "kild");
            assert_eq!(entry["to"], "my-branch");
            assert_eq!(entry["task_id"], 1);
            assert!(entry["ts"].as_str().unwrap().contains("T"));
            assert_eq!(entry["summary"], "Implement OAuth");
        });
    }

    #[test]
    fn write_task_increments_task_id() {
        with_env("wt_increments", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let r1 = write_task(
                "proj123",
                "my-branch",
                "First task",
                &[DeliveryMethod::Dropbox],
            );
            assert_eq!(r1.unwrap(), Some(1));

            let r2 = write_task(
                "proj123",
                "my-branch",
                "Second task",
                &[DeliveryMethod::Dropbox, DeliveryMethod::Pty],
            );
            assert_eq!(r2.unwrap(), Some(2));

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");

            // task-id should be 2
            let tid = std::fs::read_to_string(dropbox_dir.join("task-id")).unwrap();
            assert_eq!(tid, "2\n");

            // task.md should be overwritten with second task
            let task = std::fs::read_to_string(dropbox_dir.join("task.md")).unwrap();
            assert!(task.starts_with("# Task 2\n\n"));
            assert!(task.contains("Second task"));

            // history.jsonl should have 2 lines
            let history = std::fs::read_to_string(dropbox_dir.join("history.jsonl")).unwrap();
            let lines: Vec<&str> = history.lines().collect();
            assert_eq!(lines.len(), 2);
        });
    }

    #[test]
    fn write_task_noop_when_fleet_not_active() {
        with_env("wt_no_fleet", false, |_| {
            let result = write_task(
                "proj123",
                "my-branch",
                "Should not write",
                &[DeliveryMethod::Dropbox],
            );
            assert_eq!(result.unwrap(), None);

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            assert!(!dropbox_dir.join("task-id").exists());
        });
    }

    #[test]
    fn write_task_noop_when_dropbox_dir_missing() {
        with_env("wt_no_dir", true, |_| {
            // Fleet is active but ensure_dropbox was NOT called — dir doesn't exist.
            let result = write_task(
                "proj123",
                "my-branch",
                "Should not write",
                &[DeliveryMethod::Dropbox],
            );
            assert_eq!(result.unwrap(), None);
        });
    }

    #[test]
    fn write_task_handles_corrupt_task_id() {
        with_env("wt_corrupt_id", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            // Write garbage to task-id
            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            std::fs::write(dropbox_dir.join("task-id"), "garbage").unwrap();

            let result = write_task(
                "proj123",
                "my-branch",
                "Recover",
                &[DeliveryMethod::Dropbox],
            );
            assert_eq!(result.unwrap(), Some(1));

            let tid = std::fs::read_to_string(dropbox_dir.join("task-id")).unwrap();
            assert_eq!(tid, "1\n");
        });
    }

    #[test]
    fn write_task_records_delivery_methods() {
        with_env("wt_delivery", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            write_task(
                "proj123",
                "my-branch",
                "Test delivery",
                &[DeliveryMethod::Dropbox, DeliveryMethod::ClaudeInbox],
            )
            .unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            let history = std::fs::read_to_string(dropbox_dir.join("history.jsonl")).unwrap();
            let entry: serde_json::Value =
                serde_json::from_str(history.lines().next().unwrap()).unwrap();
            let delivery = entry["delivery"].as_array().unwrap();
            assert_eq!(delivery.len(), 2);
            assert_eq!(delivery[0], "dropbox");
            assert_eq!(delivery[1], "claude_inbox");
        });
    }

    #[test]
    fn write_task_summary_truncates_long_text() {
        with_env("wt_truncate", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let long_text = "A".repeat(200);
            write_task(
                "proj123",
                "my-branch",
                &long_text,
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            let history = std::fs::read_to_string(dropbox_dir.join("history.jsonl")).unwrap();
            let entry: serde_json::Value =
                serde_json::from_str(history.lines().next().unwrap()).unwrap();
            let summary = entry["summary"].as_str().unwrap();
            assert_eq!(summary.len(), 80, "summary should be truncated to 80 chars");
        });
    }

    #[test]
    fn write_task_summary_uses_first_line_only() {
        with_env("wt_summary_multiline", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            write_task(
                "proj123",
                "my-branch",
                "# Auth task\n\nImplement OAuth flow with PKCE for the login page.",
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            let history = std::fs::read_to_string(dropbox_dir.join("history.jsonl")).unwrap();
            let entry: serde_json::Value =
                serde_json::from_str(history.lines().next().unwrap()).unwrap();
            assert_eq!(
                entry["summary"].as_str().unwrap(),
                "# Auth task",
                "summary should use first line only, not full body"
            );
        });
    }

    #[test]
    fn write_task_clears_idle_gate_file() {
        with_env("wt_gate_clear", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            // Simulate the hook creating the gate file (as it would after first idle event).
            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            let gate_path = dropbox_dir.join(".idle_sent");
            std::fs::write(&gate_path, "").unwrap();
            assert!(
                gate_path.exists(),
                "gate file should exist before write_task"
            );

            write_task(
                "proj123",
                "my-branch",
                "new task",
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            assert!(
                !gate_path.exists(),
                "write_task should clear .idle_sent gate file"
            );
        });
    }

    #[test]
    fn write_task_succeeds_without_gate_file() {
        with_env("wt_gate_absent", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            let gate_path = dropbox_dir.join(".idle_sent");
            assert!(
                !gate_path.exists(),
                "gate file should not exist before write_task"
            );

            let result = write_task(
                "proj123",
                "my-branch",
                "new task",
                &[DeliveryMethod::Dropbox],
            );
            assert!(
                result.is_ok(),
                "write_task should succeed without gate file"
            );
        });
    }

    // --- read_dropbox_state ---

    #[test]
    fn read_dropbox_state_returns_none_when_fleet_not_active() {
        with_env("rds_no_fleet", false, |_| {
            let result = read_dropbox_state("proj123", "my-branch").unwrap();
            assert!(
                result.is_none(),
                "should return None when fleet is not active"
            );
        });
    }

    #[test]
    fn read_dropbox_state_returns_none_when_dir_missing() {
        with_env("rds_no_dir", true, |_| {
            // Fleet active but ensure_dropbox not called — dir missing.
            let result = read_dropbox_state("proj123", "my-branch").unwrap();
            assert!(
                result.is_none(),
                "should return None when dropbox dir missing"
            );
        });
    }

    #[test]
    fn read_dropbox_state_empty_dropbox_returns_all_none_fields() {
        with_env("rds_empty", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let state = read_dropbox_state("proj123", "my-branch")
                .unwrap()
                .expect("should return Some for existing dropbox");

            assert_eq!(&*state.branch, "my-branch");
            assert!(state.task_id.is_none());
            assert!(state.task_content.is_none());
            assert!(state.ack.is_none());
            assert!(state.report.is_none());
            assert!(state.latest_history.is_none());
        });
    }

    #[test]
    fn read_dropbox_state_after_write_task() {
        with_env("rds_after_write", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            write_task(
                "proj123",
                "my-branch",
                "Implement OAuth",
                &[DeliveryMethod::Dropbox, DeliveryMethod::ClaudeInbox],
            )
            .unwrap();

            let state = read_dropbox_state("proj123", "my-branch")
                .unwrap()
                .expect("should return Some after write_task");

            assert_eq!(state.task_id, Some(1));
            assert!(
                state
                    .task_content
                    .as_ref()
                    .unwrap()
                    .contains("Implement OAuth")
            );
            assert!(state.ack.is_none());
            assert!(state.report.is_none());

            let history = state.latest_history.expect("should have history entry");
            assert_eq!(history.task_id, 1);
            assert_eq!(history.delivery.len(), 2);
            assert_eq!(history.delivery[0], DeliveryMethod::Dropbox);
            assert_eq!(history.delivery[1], DeliveryMethod::ClaudeInbox);
        });
    }

    #[test]
    fn read_dropbox_state_with_ack_and_report() {
        with_env("rds_ack_report", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            write_task(
                "proj123",
                "my-branch",
                "Fix the bug",
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            std::fs::write(dropbox_dir.join("ack"), "1\n").unwrap();
            std::fs::write(dropbox_dir.join("report.md"), "Done. All tests pass.\n").unwrap();

            let state = read_dropbox_state("proj123", "my-branch")
                .unwrap()
                .expect("should return Some");

            assert_eq!(state.ack, Some(1));
            assert_eq!(state.report.as_deref(), Some("Done. All tests pass.\n"));
        });
    }

    #[test]
    fn read_dropbox_state_corrupt_ack_returns_none() {
        with_env("rds_corrupt_ack", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            write_task("proj123", "my-branch", "Task", &[DeliveryMethod::Dropbox]).unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            std::fs::write(dropbox_dir.join("ack"), "garbage").unwrap();

            let state = read_dropbox_state("proj123", "my-branch")
                .unwrap()
                .expect("should return Some");

            assert!(state.ack.is_none(), "corrupt ack should be None, not error");
            assert_eq!(state.task_id, Some(1), "task_id should still be readable");
        });
    }

    #[test]
    fn read_dropbox_state_corrupt_history_returns_none() {
        with_env("rds_corrupt_history", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            write_task("proj123", "my-branch", "Task", &[DeliveryMethod::Dropbox]).unwrap();

            let paths = KildPaths::resolve().unwrap();
            let dropbox_dir = paths.fleet_dropbox_dir("proj123", "my-branch");
            // Overwrite history with garbage
            std::fs::write(dropbox_dir.join("history.jsonl"), "not valid json\n").unwrap();

            let state = read_dropbox_state("proj123", "my-branch")
                .unwrap()
                .expect("should return Some");

            assert!(
                state.latest_history.is_none(),
                "corrupt history should be None, not error"
            );
            assert_eq!(state.task_id, Some(1), "task_id should still be readable");
        });
    }

    // --- generate_prime_context ---

    #[test]
    fn generate_prime_context_returns_none_when_fleet_not_active() {
        with_env("prime_no_fleet", false, |_| {
            let result = generate_prime_context("proj123", "my-branch", &[]).unwrap();
            assert!(
                result.is_none(),
                "should return None when fleet is not active"
            );
        });
    }

    #[test]
    fn generate_prime_context_returns_protocol_and_empty_state() {
        with_env("prime_empty", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let ctx = generate_prime_context("proj123", "my-branch", &[])
                .unwrap()
                .expect("should return Some for fleet-active session");

            assert_eq!(&*ctx.branch, "my-branch");
            assert!(
                ctx.protocol.is_some(),
                "protocol.md should be read from disk"
            );
            assert!(
                ctx.protocol
                    .as_ref()
                    .unwrap()
                    .contains("KILD Fleet Protocol"),
                "protocol should contain fleet instructions"
            );
            // Dropbox exists but no task written yet
            let state = ctx
                .dropbox_state
                .expect("dropbox exists, state should be Some");
            assert!(state.task_id.is_none());
            assert!(ctx.fleet.is_empty());
        });
    }

    #[test]
    fn generate_prime_context_includes_task_state() {
        with_env("prime_task", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");
            write_task(
                "proj123",
                "my-branch",
                "Implement OAuth",
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            let ctx = generate_prime_context("proj123", "my-branch", &[])
                .unwrap()
                .expect("should return Some");

            let state = ctx.dropbox_state.expect("should have dropbox state");
            assert_eq!(state.task_id, Some(1));
            assert!(
                state
                    .task_content
                    .as_ref()
                    .unwrap()
                    .contains("Implement OAuth")
            );
        });
    }

    #[test]
    fn generate_prime_context_fleet_entries_from_sessions() {
        use std::path::PathBuf;

        with_env("prime_fleet", true, |_| {
            // Set up dropboxes for brain and worker
            ensure_dropbox("proj123", fleet::BRAIN_BRANCH, "claude");
            ensure_dropbox("proj123", "worker-a", "claude");
            write_task(
                "proj123",
                "worker-a",
                "Do the work",
                &[DeliveryMethod::Dropbox],
            )
            .unwrap();

            // Construct mock sessions
            let mut brain = Session::new_for_test(fleet::BRAIN_BRANCH, PathBuf::from("/tmp/brain"));
            brain.project_id = kild_protocol::ProjectId::new("proj123");
            let mut worker = Session::new_for_test("worker-a", PathBuf::from("/tmp/worker"));
            worker.agent = "claude".to_string();
            worker.project_id = kild_protocol::ProjectId::new("proj123");

            let sessions = vec![brain, worker];

            let ctx = generate_prime_context("proj123", "worker-a", &sessions)
                .unwrap()
                .expect("should return Some");

            assert_eq!(ctx.fleet.len(), 2);

            // Brain entry
            let brain_entry = ctx.fleet.iter().find(|e| e.is_brain).unwrap();
            assert_eq!(&*brain_entry.branch, fleet::BRAIN_BRANCH);
            assert!(brain_entry.is_brain);

            // Worker entry
            let worker_entry = ctx.fleet.iter().find(|e| &*e.branch == "worker-a").unwrap();
            assert!(!worker_entry.is_brain);
            assert_eq!(worker_entry.task_id, Some(1));
            assert!(worker_entry.ack.is_none());
        });
    }

    #[test]
    fn to_markdown_contains_all_sections() {
        let ctx = PrimeContext {
            branch: BranchName::from("worker-a"),
            protocol: Some("# KILD Fleet Protocol\nYou are a worker.".to_string()),
            dropbox_state: Some(DropboxState {
                branch: BranchName::from("worker-a"),
                task_id: Some(1),
                task_content: Some("# Task 1\n\nImplement OAuth.".to_string()),
                ack: Some(1),
                report: None,
                latest_history: None,
            }),
            fleet: vec![
                FleetEntry {
                    branch: BranchName::from(fleet::BRAIN_BRANCH),
                    agent: "claude".to_string(),
                    session_status: SessionStatus::Active,
                    agent_status: None,
                    task_id: None,
                    ack: None,
                    is_brain: true,
                },
                FleetEntry {
                    branch: BranchName::from("worker-a"),
                    agent: "claude".to_string(),
                    session_status: SessionStatus::Active,
                    agent_status: Some(AgentStatus::Idle),
                    task_id: Some(1),
                    ack: Some(1),
                    is_brain: false,
                },
            ],
        };

        let md = ctx.to_markdown();
        assert!(md.contains("# KILD Fleet Context — worker-a"));
        assert!(md.contains("## Your Protocol"));
        assert!(md.contains("You are a worker."));
        assert!(md.contains("## Current Task"));
        assert!(md.contains("Task ID: 001"));
        assert!(md.contains("Acked: 1 (current)"));
        assert!(md.contains("## Fleet Status"));
        assert!(md.contains("claude (brain)"));
        assert!(md.contains("worker-a"));
    }

    #[test]
    fn to_status_markdown_contains_only_fleet_table() {
        let ctx = PrimeContext {
            branch: BranchName::from("worker-a"),
            protocol: Some("protocol content".to_string()),
            dropbox_state: None,
            fleet: vec![FleetEntry {
                branch: BranchName::from("worker-a"),
                agent: "claude".to_string(),
                session_status: SessionStatus::Active,
                agent_status: None,
                task_id: None,
                ack: None,
                is_brain: false,
            }],
        };

        let md = ctx.to_status_markdown();
        assert!(md.contains("# Fleet Status — worker-a"));
        assert!(md.contains("## Fleet Status"));
        assert!(
            !md.contains("Your Protocol"),
            "should not include protocol section"
        );
        assert!(
            !md.contains("Current Task"),
            "should not include task section"
        );
    }

    #[test]
    fn to_markdown_stale_ack_shows_stale_label() {
        let ctx = PrimeContext {
            branch: BranchName::from("worker-a"),
            protocol: None,
            dropbox_state: Some(DropboxState {
                branch: BranchName::from("worker-a"),
                task_id: Some(3),
                task_content: Some("Task 3".to_string()),
                ack: Some(2),
                report: None,
                latest_history: None,
            }),
            fleet: vec![],
        };

        let md = ctx.to_markdown();
        assert!(
            md.contains("Acked: 2 (stale)"),
            "stale ack should be labeled stale"
        );
        assert!(
            !md.contains("(current)"),
            "stale ack should not show (current)"
        );
    }

    #[test]
    fn to_markdown_omits_protocol_section_when_none() {
        let ctx = PrimeContext {
            branch: BranchName::from("worker-a"),
            protocol: None,
            dropbox_state: None,
            fleet: vec![],
        };

        let md = ctx.to_markdown();
        assert!(!md.contains("## Your Protocol"));
        assert!(md.contains("No task assigned."));
        assert!(md.contains("No fleet sessions."));
    }

    // --- clear_idle_gate ---

    #[test]
    fn clear_idle_gate_removes_existing_gate_file() {
        with_env("cig_exists", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            let paths = KildPaths::resolve().unwrap();
            let gate_path = paths
                .fleet_dropbox_dir("proj123", "my-branch")
                .join(".idle_sent");
            std::fs::write(&gate_path, "").unwrap();
            assert!(gate_path.exists(), "gate file should exist before clear");

            clear_idle_gate("proj123", "my-branch");

            assert!(
                !gate_path.exists(),
                "clear_idle_gate should remove .idle_sent"
            );
        });
    }

    #[test]
    fn clear_idle_gate_noop_when_no_gate_file() {
        with_env("cig_absent", true, |_| {
            ensure_dropbox("proj123", "my-branch", "claude");

            // No gate file created — clear_idle_gate should not panic or error.
            clear_idle_gate("proj123", "my-branch");

            let paths = KildPaths::resolve().unwrap();
            let gate_path = paths
                .fleet_dropbox_dir("proj123", "my-branch")
                .join(".idle_sent");
            assert!(!gate_path.exists());
        });
    }

    #[test]
    fn clear_idle_gate_noop_when_fleet_not_active() {
        with_env("cig_no_fleet", false, |_| {
            // Fleet not active — should not panic or error.
            clear_idle_gate("proj123", "my-branch");
        });
    }
}
